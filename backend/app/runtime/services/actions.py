"""
Action routing for the new runtime engine.
"""

from __future__ import annotations

from app.models.effects import MoveToEffect, MoveEffect
from app.runtime.session import SessionRuntime


class ActionService:
    """Executes player actions by applying effects/goto transitions."""

    def __init__(self, runtime: SessionRuntime) -> None:
        self.runtime = runtime
        self.effect_resolver = runtime.effect_resolver
        self.inventory = runtime.inventory_service
        self.trade = getattr(runtime, "trade_service", None)

    def execute(self, ctx, action) -> None:
        if action.action_type == "choice":
            if not action.choice_id:
                raise ValueError("choice action requires choice_id")
            self._handle_predefined_choice(ctx, action.choice_id)
        elif action.action_type in {"say", "do"}:
            # Freeform actions currently rely on AI/Checker for state deltas.
            return
        elif action.action_type == "use":
            if not action.item_id:
                raise ValueError("use action requires item_id")
            self._handle_use_item(action.item_id)
        elif action.action_type == "shop_buy":
            self._handle_shop_buy(action)
        elif action.action_type == "shop_sell":
            self._handle_shop_sell(action)
        elif action.action_type == "do":
            # For side-effect-only turns, reevaluate gates after context is created.
            return
        elif action.action_type == "give":
            if not action.item_id or not action.target:
                raise ValueError("give action requires item_id and target")
            self._handle_give_item(action.item_id, action.target)
        elif action.action_type == "move":
            if not action.direction:
                raise ValueError("move action requires direction")
            self._handle_move_direction(action.direction, action.with_characters)
        elif action.action_type == "goto":
            if not action.location:
                raise ValueError("goto action requires location")
            self._handle_goto_location(action.location, action.with_characters)
        elif action.action_type == "travel":
            if not action.location:
                raise ValueError("travel action requires location")
            self._handle_travel(action.location, action.with_characters)
        else:
            raise ValueError(f"Unsupported action_type: {action.action_type}")

    # ------------------------------------------------------------------ #
    # Internal helpers
    # ------------------------------------------------------------------ #

    def _handle_predefined_choice(self, ctx, choice_id: str) -> None:
        state = self.runtime.state_manager.state
        node = ctx.current_node

        def _apply_choice(choice):
            effects = getattr(choice, "effects", None)
            if effects is None:
                effects = getattr(choice, "on_select", None)
            if effects:
                self.effect_resolver.apply_effects(effects)
            if getattr(choice, "goto", None):
                state.current_node = choice.goto

        # Event choices take priority
        for choice in ctx.event_choices:
            if choice.id == choice_id:
                _apply_choice(choice)
                return

        # Movement choices (generated by ChoiceBuilder)
        if choice_id.startswith("move_") and self.runtime.movement_service:
            destination = choice_id.removeprefix("move_")
            self.runtime.movement_service.move_to(MoveToEffect(location=destination, with_characters=[]))
            return

        for choice in list(node.choices or []) + list(node.dynamic_choices or []):
            if choice.id == choice_id:
                _apply_choice(choice)
                return

        # Fallback to unlocked actions
        action_def = self.runtime.index.actions.get(choice_id)
        if action_def and choice_id in (state.unlocked_actions or []):
            effects = getattr(action_def, "effects", None) or getattr(action_def, "on_select", None)
            if effects:
                self.effect_resolver.apply_effects(effects)
            return

        raise ValueError(f"Choice '{choice_id}' not found in current context.")

    def _handle_use_item(self, item_id: str) -> None:
        if not self.inventory:
            raise RuntimeError("Inventory service not available")
        hooks = self.inventory.use_item("player", item_id)
        if hooks:
            self.effect_resolver.apply_effects(hooks)

    def _handle_give_item(self, item_id: str, target: str) -> None:
        if self.trade and self.inventory:
            hooks = self.trade.give(
                type(
                    "GiveEffectProxy",
                    (),
                    {
                        "source": "player",
                        "target": target,
                        "item_type": self.inventory.get_item_type(item_id) or "item",
                        "item": item_id,
                        "count": 1,
                    },
                )
            )
            if hooks:
                self.effect_resolver.apply_effects(hooks)
            return

        if not self.inventory:
            raise RuntimeError("Inventory service not available")
        hooks = self.inventory.give_item("player", target, item_id)
        if hooks:
            self.effect_resolver.apply_effects(hooks)

    def _handle_shop_buy(self, action) -> None:
        if not self.trade:
            raise ValueError("Trade service not available for shop_buy")
        source = None
        count = 1
        if getattr(action, "extra", None):
            source = action.extra.get("source")
            count = action.extra.get("count", 1)
        hooks = self.trade.purchase(
            type(
                "PurchaseProxy",
                (),
                {
                    "target": action.target or "player",
                    "source": source or self.runtime.state_manager.state.current_location,
                    "item_type": self.inventory.get_item_type(action.item_id) if self.inventory else "item",
                    "item": action.item_id,
                    "count": count,
                    "price": None,
                },
            )
        )
        if hooks:
            self.effect_resolver.apply_effects(hooks)

    def _handle_shop_sell(self, action) -> None:
        if not self.trade:
            raise ValueError("Trade service not available for shop_sell")
        source = None
        count = 1
        if getattr(action, "extra", None):
            source = action.extra.get("source")
            count = action.extra.get("count", 1)
        hooks = self.trade.sell(
            type(
                "SellProxy",
                (),
                {
                    "source": source or "player",
                    "target": action.target or self.runtime.state_manager.state.current_location,
                    "item_type": self.inventory.get_item_type(action.item_id) if self.inventory else "item",
                    "item": action.item_id,
                    "count": count,
                    "price": None,
                },
            )
        )
        if hooks:
            self.effect_resolver.apply_effects(hooks)

    def _handle_move_direction(self, direction: str, companions: list[str] | None) -> None:
        """Handle compass direction movement (move action)."""
        movement_service = getattr(self.runtime, "movement_service", None)
        if not movement_service:
            raise RuntimeError("Movement service not available")

        # Check NPC willingness if moving with companions
        if companions:
            self._validate_companion_willingness(companions, "move")

        # Execute movement by direction
        effect = MoveEffect(direction=direction, with_characters=companions or [])
        result = movement_service.move_relative(effect)
        if not result:
            raise ValueError(f"Cannot move in direction '{direction}' from current location")

    def _handle_goto_location(self, location: str, companions: list[str] | None) -> None:
        """Handle direct location movement (goto action)."""
        movement_service = getattr(self.runtime, "movement_service", None)
        if not movement_service:
            raise RuntimeError("Movement service not available")

        # Check NPC willingness if moving with companions
        if companions:
            self._validate_companion_willingness(companions, "goto")

        # Execute local movement to specific location
        effect = MoveToEffect(location=location, with_characters=companions or [])
        success = movement_service.move_to(effect)
        if not success:
            raise ValueError(f"Cannot move to location '{location}'")

    def _handle_travel(self, location: str, companions: list[str] | None) -> None:
        """Handle zone-to-zone travel (travel action)."""
        from app.models.effects import TravelToEffect

        movement_service = getattr(self.runtime, "movement_service", None)
        if not movement_service:
            raise RuntimeError("Movement service not available")

        # Check NPC willingness if traveling with companions
        if companions:
            self._validate_companion_willingness(companions, "travel")

        # Execute inter-zone travel
        # Use "walk" as default method for travel action
        effect = TravelToEffect(
            location=location,
            method="walk",
            with_characters=companions or []
        )
        success = movement_service.travel(effect)
        if not success:
            raise ValueError(f"Cannot travel to location '{location}'")

    def _validate_companion_willingness(self, companions: list[str], action_context: str) -> None:
        """
        Validate that NPCs are willing to move with the player.

        Args:
            companions: List of character IDs
            action_context: Context for error messages (move/goto/travel)

        Raises:
            ValueError: If any companion is unwilling or not present
        """
        state = self.runtime.state_manager.state

        for char_id in companions:
            # Skip player
            if char_id == "player":
                continue

            # Check if character is present
            if char_id not in state.present_characters:
                raise ValueError(
                    f"Cannot {action_context} with {char_id}: character not present"
                )

            # Check willingness via gates
            char_state = state.characters.get(char_id)
            if char_state:
                gates = getattr(char_state, "gates", {}) or getattr(char_state, "gates_full", {})

                # Check generic movement willingness gate
                if "follow_player" in gates and not gates["follow_player"]:
                    raise ValueError(
                        f"Cannot {action_context} with {char_id}: character unwilling to follow"
                    )

                # Check specific action context gates if they exist
                gate_key = f"follow_player_{action_context}"
                if gate_key in gates and not gates[gate_key]:
                    raise ValueError(
                        f"Cannot {action_context} with {char_id}: character unwilling"
                    )
